; Note: Portions of this file come from this implementation:
; https://github.com/tiangolo/uwsgi-nginx-docker/blob/master/docker-images/uwsgi.ini

[uwsgi]
; By default uwsgi will look for plugins in the current working directory. We need
; to make sure it adds the local installation directory to its plugin search path.
plugins-dir = /usr/local/src/uwsgi-$(UWSGI_VERSION)

; Load the Python 3 plugin to uWSGI. Because it's installed from an Alpine system
; package and not built from source, Python 3 isn't built into the uWSGI core and
; has to be loaded explicitly.
plugins = python3

; Filesystem location of the Unix socket that Nginx uses to communicate with uWSGI.
; It isn't explicit, but this setting can be either a Unix socket or a TCP socket,
; depending on the value--setting it to something like 127.0.0.1:3031 would make 
; it a TCP socket, and the Nginx `uwsgi_pass` setting would need to be set to the
; same value. We're using a Unix socket to avoid involving the network stack, on
; the assumption that throughput inside a single host will be faster using a 
; filesystem socket rather than a networking socket.
socket = /tmp/libreg_uwsgi.sock

; The socket should be owned by the nginx user, and must be readable/writable
chown-socket = nginx:nginx
chmod-socket = 664

; If we are running as root, we should drop privileges to the nginx user/group.
; The value 101 is set as the uid/gid during the Nginx install, which happens in
; the Dockerfile's `builder` intermediate target.
uid = 101
gid = 101

; Graceful shutdown on SIGTERM when running under Docker
; See https://github.com/unbit/uwsgi/issues/849#issuecomment-118869386
hook-master-start = unix_signal:15 gracefully_kill_them_all
die-on-term = true

; uWSGI workers shouldn't be able to run without a Python app (in this implementation)
need-app = true

; The project's base directory.
chdir = /libreg_app

; The virtualenv setting is the path to the virtualenv associated with the app. While 
; the name of the virtualenv should be deterministic, I'm using a shell glob to
; find it just in case the way pipenv creates the hash in the directory name
; happens to change, since that's (I think) an undocumented, internal method.
;
; The pythonpath setting needs to explicitly include the virtualenv's site packages
; and core libs, or uWSGI won't find them. Because it's crap software. THERE, I SAID IT.
for-glob = /libreg_venv/libreg_app-*
  virtualenv = %(_)
  pythonpath = %(_)/lib/python3.9/site-packages/
  pythonpath = %(_)/lib/python3.9
endfor =

; The Python module which contains the WSGI callable
module = library_registry.app

; The name of the variable in `module` that is the WSGI callable
callable = app

; Log file and format string
logto = /var/log/uwsgi/libreg_uwsgi.log
log-format = %(addr) - - [%(ltime)] "%(method) %(uri) %(proto)" %(status) %(size) "%(referer)" "%(uagent)" host_hdr=%(host) req_time_elapsed=%(msecs)

; The app(s) are loaded in each worker on init, rather than in the master process
enable-threads = false
lazy-apps = true

; The process reap timeout, in seconds, for stuck worker processes.
; 30 is the default value, including it here so it's clear how to change it
; if that becomes an issue being tested.
harakiri = 30

; Number of worker processes is twice the number of detected CPUs, plus 1
; (%k is a uWSGI 'magic variable' for the number of detected CPUs)
processes = %((%k * 2) + 1)

; Threads per worker process
threads = 2